var searchIndex = JSON.parse('{\
"huffman":{"doc":"A simple Huffman Compression Algorithm implementation.","t":"AAAFAAAFFFFFDLLLLLLMLLLLLDLLLLLMLLLLLLLLLLLMDLLLLFLLMLLLLLLLLLLLLLLMDLLLLLMMLMLLL","n":["compress","decompress","heap","main","node","parsing","tree","build_frequency_list","build_huffman_tree","heap_sort","main","main","Heap","borrow","borrow_mut","from","into","is_empty","new","nodes","pop","push","try_from","try_into","type_id","Node","add_one","borrow","borrow_mut","clone","clone_into","elt","eq","fmt","from","get_elt","get_value","into","new","to_owned","try_from","try_into","type_id","value","Args","augment_args","augment_args_for_update","borrow","borrow_mut","check_command","clone","clone_into","command","fmt","from","from_arg_matches","from_arg_matches_mut","get_command","into","into_app","into_app_for_update","to_owned","try_from","try_into","type_id","update_from_arg_matches","update_from_arg_matches_mut","verbose","Tree","borrow","borrow_mut","from","get_key","into","key","left","new","right","try_from","try_into","type_id"],"q":[[0,"huffman"],[7,"huffman::compress"],[11,"huffman::decompress"],[12,"huffman::heap"],[25,"huffman::node"],[44,"huffman::parsing"],[68,"huffman::tree"]],"d":["This module contains all the function to compress a text …","This module contains all the things to decompress a text …","This module contains some structs and implementations that …","Launches the program, parses arguements and play!","This module contains the <code>Node</code> struct and  its …","This module contains all things related to parsing command …","This module contains the <code>Tree</code> struct and implementation.","Creates a list of nodes, by frequency.","","Helper who sort the list in the right order.","","","Stores the nodes forming the heap.","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Checks if a heap is empty or bot.","Allows to create a new heap and returns it. The heap …","The nodes of the heap.","Removes and return the first element of the heap.","Add an element at the right place in the heap.","","","","An element of the heap, defined by its value and its elt.","","","","","","The stored value (here a char)","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Allows to create a new node for the heap and returns it.","","","","","For priority in the heap","","","","","","","","","Command [compress | decompress]","","Returns the argument unchanged.","","","","Calls <code>U::from(self)</code>.","","","","","","","","","Enable verbose mode","Struct of the Tree","","","Returns the argument unchanged.","Returns the key of the tree.","Calls <code>U::from(self)</code>.","The key of the node, here a char.","Link to the left tree.","Allows to create a new Tree.","Link to the right tree.","","",""],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,5,5,5,5,5,5,5,5,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,15,15,15,15,0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,4,4,4,4,4,4,4,4,4,4,4,4],"f":[0,0,0,[[]],0,0,0,[1,[[3,[2]]]],[[[3,[2]]],4],[[[3,[2]]],[[3,[2]]]],[1,1],[1,1],0,[[]],[[]],[[]],[[]],[5,6],[[],5],0,[5,[[8,[2,7]]]],[[5,2],5],[[],8],[[],8],[[],9],0,[2],[[]],[[]],[2,2],[[]],0,[[2,2],6],[[2,10],11],[[]],[2,12],[2,13],[[]],[[13,12],2],[[]],[[],8],[[],8],[[],9],0,0,[14,14],[14,14],[[]],[[]],[1,[[8,[7,7]]]],[15,15],[[]],0,[[15,10],11],[[]],[16,[[8,[15,17]]]],[16,[[8,[15,17]]]],[15,7],[[]],[[],14],[[],14],[[]],[[],8],[[],8],[[],9],[[15,16],[[8,[17]]]],[[15,16],[[8,[17]]]],0,0,[[]],[[]],[[]],[4,12],[[]],0,0,[[12,[19,[[18,[4]]]],[19,[[18,[4]]]]],4],0,[[],8],[[],8],[[],9]],"c":[],"p":[[15,"str"],[3,"Node"],[3,"Vec"],[3,"Tree"],[3,"Heap"],[15,"bool"],[3,"String"],[4,"Result"],[3,"TypeId"],[3,"Formatter"],[6,"Result"],[15,"char"],[15,"usize"],[6,"Command"],[3,"Args"],[3,"ArgMatches"],[3,"Error"],[3,"Box"],[4,"Option"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
