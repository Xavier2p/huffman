var searchIndex = JSON.parse('{\
"huffman":{"doc":"A simple <em>Huffman Compression Algorithm</em> implementation.","t":"AAAFAAAFFFFFFFFFFFDLLLLLLMLLLLLDLLLLLMLLLLLLLLLLLMDLLLLFLLMLLLLLLLLLLLLLLMDLLLLLLLMMLMLLLL","n":["compress","decompress","heap","main","node","parsing","tree","build_frequency_list","build_huffman_tree","encode_data","encode_tree","heap_sort","main","to_binary","decode_data","decode_tree","from_binary","main","Heap","borrow","borrow_mut","from","into","is_empty","new","nodes","pop","push","try_from","try_into","type_id","Node","add_one","borrow","borrow_mut","clone","clone_into","elt","eq","fmt","from","get_elt","get_value","into","new","to_owned","try_from","try_into","type_id","value","Args","augment_args","augment_args_for_update","borrow","borrow_mut","check_command","clone","clone_into","command","fmt","from","from_arg_matches","from_arg_matches_mut","get_command","into","into_app","into_app_for_update","to_owned","try_from","try_into","type_id","update_from_arg_matches","update_from_arg_matches_mut","verbose","Tree","borrow","borrow_mut","clone","clone_into","from","get_key","into","key","left","new","right","to_owned","try_from","try_into","type_id"],"q":[[0,"huffman"],[7,"huffman::compress"],[14,"huffman::decompress"],[18,"huffman::heap"],[31,"huffman::node"],[50,"huffman::parsing"],[74,"huffman::tree"]],"d":["This module contains all the function to compress a text …","This module contains all the things to decompress a text …","This module contains some structs and implementations that …","Launches the program, parses arguements and play!","This module contains the <code>Node</code> struct and  its …","This module contains all things related to parsing command …","This module contains the <code>Tree</code> struct and implementation.","Builds a <code>Node</code> list of the character frequencies in the …","Processes the frequency list into a Huffman tree according …","Encodes the input string to its binary string …","Encodes a huffman tree to its binary representation using …","Helper who sort the list in the right order.","The main function that makes the whole compression process.","Compresses a string containing binary code to its real …","Decodes a string using the corresponding huffman tree into …","Decodes a huffman tree from its binary representation:","Retrieve a string containing binary code from its real …","The whole decompression process.","Stores the nodes forming the heap.","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Checks if a heap is empty or bot.","Allows to create a new heap and returns it. The heap …","The nodes of the heap.","Removes and return the first element of the heap.","Add an element at the right place in the heap.","","","","An element of the heap, defined by its value and its elt.","Adds one to the value of the node. In-place.","","","","","The stored value (here a char)","","","Returns the argument unchanged.","Getter for the <code>elt</code> of the node.","Getter for the <code>value</code> of the node.","Calls <code>U::from(self)</code>.","Allows to create a new node for the heap and returns it.","","","","","For priority in the heap","","","","","","","","","Command [compress | decompress]","","Returns the argument unchanged.","","","","Calls <code>U::from(self)</code>.","","","","","","","","","Enable verbose mode","Struct of the Tree","","","","","Returns the argument unchanged.","Returns the key of the tree.","Calls <code>U::from(self)</code>.","The key of the node, here a char.","Link to the left tree.","Allows to create a new Tree.","Link to the right tree.","","","",""],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,8,8,8,8,8,8,8,8,8,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,18,18,18,18,0,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],"f":[0,0,0,[[]],0,0,0,[1,[[4,[[3,[2]]]]]],[[[4,[[3,[2]]]]],5],[[5,1],1],[5,1],[[[4,[[3,[6]]]]],[[4,[[3,[6]]]]]],[1],[1],[[5,1],1],[1,5],[[1,7],1],[[1,7,1,7],1],0,[[]],[[]],[[]],[[]],[[[8,[6]]],9],[[],[[8,[6]]]],0,[[[8,[6]]],[[11,[[3,[6]],10]]]],[[[8,[6]],[3,[6]]],[[8,[6]]]],[[],11],[[],11],[[],12],0,[[[3,[6]]]],[[]],[[]],[[[3,[[0,[6,6]]]]],[[3,[[0,[6,6]]]]]],[[]],0,[[[3,[[0,[6,13]]]],[3,[[0,[6,13]]]]],9],[[[3,[[0,[6,14]]]],15],16],[[]],[[[3,[6]]],6],[[[3,[6]]],7],[[]],[[7,6],[[3,[6]]]],[[]],[[],11],[[],11],[[],12],0,0,[17,17],[17,17],[[]],[[]],[1,[[11,[10,10]]]],[18,18],[[]],0,[[18,15],16],[[]],[19,[[11,[18,20]]]],[19,[[11,[18,20]]]],[18,10],[[]],[[],17],[[],17],[[]],[[],11],[[],11],[[],12],[[18,19],[[11,[20]]]],[[18,19],[[11,[20]]]],0,0,[[]],[[]],[5,5],[[]],[[]],[5,2],[[]],0,0,[[2,[22,[[21,[5]]]],[22,[[21,[5]]]]],5],0,[[]],[[],11],[[],11],[[],12]],"c":[],"p":[[15,"str"],[15,"char"],[3,"Node"],[3,"Vec"],[3,"Tree"],[8,"Clone"],[15,"usize"],[3,"Heap"],[15,"bool"],[3,"String"],[4,"Result"],[3,"TypeId"],[8,"PartialEq"],[8,"Debug"],[3,"Formatter"],[6,"Result"],[6,"Command"],[3,"Args"],[3,"ArgMatches"],[3,"Error"],[3,"Box"],[4,"Option"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
